# -*- coding: utf-8 -*-
"""Cópia de atividade_1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hsogp1rvHjoMM2i_zcTgs1Bohzun2Lfb
"""

#!pip install ortools

#################################################################################################
# Problema do Caixeiro Viajante
#Copyright 2023 Mateus Chacon, Mario Villalba, Danielle Gomes e Felipe Ribeiro

# Este programa é um software livre, você pode redistribuí-lo e/ou modificá-lo
# sob os termos da Licença Pública Geral GNU como publicada pela Fundação do Software Livre (FSF),
# na versão 3 da Licença, ou (a seu critério) qualquer versão posterior.

# Este programa é distribuído na esperança de que possa ser útil, mas SEM NENHUMA GARANTIA,
# e sem uma garantia implícita de ADEQUAÇÃO a qualquer MERCADO ou APLICAÇÃO EM PARTICULAR.

# Veja a Licença Pública Geral GNU para mais detalhes
#################################################################################################

from time import gmtime, strftime
import numpy as np
import time
from ortools.linear_solver import pywraplp
#************************************************************************************************
#FUNÇÃO DE LEITURA
#************************************************************************************************
def leia(fileAq):
  arq = open(fileAq, 'r')
  texto = arq.readlines()
  matrix = []
  for linha in texto :
    v = str(linha).split()
    line = []
    for number in range(len(v)):
      line.append(int(v[number]))
    matrix.append(line)
  arq.close()
  return np.array(matrix)
#************************************************************************************************
#FUNÇÃO QUE EXECUTA O SOLVER
#************************************************************************************************
def modelo(distances, subTours ,useMTZ=True, writeLp=False):
  n = distances.shape[0]

  #criando as variaveis xij
  solver = pywraplp.Solver.CreateSolver('SAT')
  x = {}
  for i in range(n):
      for j in range(n):
          if i != j:
            vname = f'x_{i}_{j}'
            x[i,j] = solver.BoolVar(vname)

  # criando a função objetiva
  solver.Minimize(solver.Sum(distances[i, j] * x[i, j] for i in range(n) for j in range(n) if i != j))

  # adicionando restrição para todo i
  for i in range(n):
      solver.Add(solver.Sum(x[i, j] for j in range(n) if i != j) == 1, name=f'degree_{i}')

  # adicionando restrição para todo j
  for j in range(n):
      solver.Add(solver.Sum(x[i, j] for i in range(n) if i != j) == 1, name=f'degree_{j}')

  # Add MTZ constraints
  if(useMTZ):
    u = {}
    for i in range(1, n):
        vname = f'u_{i}'
        u[i] = solver.IntVar(1 , n-1 ,vname)

    for i in range(1, n):
        for j in range(1, n):
            if i != j:
                solver.Add(u[i] - u[j] + (n - 1) * x[i, j] <= n - 2, name=f'mtz_{i}_{j}')

  # Add restrição sub rotas
  for m in range(len(subTours)):
        r5 = 0
        for i in range(len(subTours[m])):
            for j in range(len(subTours[m])):
                if i != j:
                    r5 += x[subTours[m][i], subTours[m][j]]
        solver.Add(r5 <= len(subTours[m]) - 1, name=f"sub_{m}_{i}_{j}")

  # gera o lp do modelo
  lp = "model-LP-"+str(strftime("%Y-%m-%dT%H:%M:%S", gmtime()))+".mps"
  if writeLp:
    with open(lp, "w") as out_f:
        mps_text = solver.ExportModelAsLpFormat(False)
        out_f.write(mps_text)

  #executa o solver
  init = time.time()
  status = solver.Solve()
  fim = time.time()
  if status == pywraplp.Solver.OPTIMAL or status == pywraplp.Solver.FEASIBLE:
    coords = []
    for i in range(n):
      for j in range(n):
        if (i != j):
          if round(x[j,i].solution_value()) == 1:
            coords.append([i,j])
    print('')
    print('Solution: Objective value =', solver.Objective().Value(), 'AND execution in =', round(fim-init), '[s]')
    return solver.Objective().Value(), coords
  else:
    print("Infeasible")
#************************************************************************************************
#FUNÇÃO QUE RETORNA OS SUB ROTAS
#************************************************************************************************
def createSubTours(coords):
    n = len(coords)
    cities_left = set(range(n))  # Conjunto de índices das cidades não visitadas
    sub_tours = []
    while cities_left:
        current_city = cities_left.pop()  # Inicia um novo sub-tour
        sub_tour = [current_city]
        while True:
            found_next = False
            for i in range(n):
                if coords[current_city][1] == coords[i][0] and i in cities_left:
                    current_city = i
                    sub_tour.append(current_city)
                    cities_left.remove(current_city)
                    found_next = True
                    break
            if not found_next:
                break
        sub_tours.append(sub_tour)
    return sub_tours
#************************************************************************************************
#FUNÇÃO QUE RETORNA AS ROTAS
#************************************************************************************************

def __main__():
  distances = leia('bays58.txt')
  useMtz = False
  #useMtz = True
  writeLp = False
  # writeLp = True

  init = time.time()
  subTours = []
  for i in range(100):
    fo, coords = modelo(distances,subTours,useMtz,writeLp)
    subToursCorrent = createSubTours(coords)

    if(len(subToursCorrent)==1):
      print(subToursCorrent)
      break

    subTours.extend(subToursCorrent)
    
  fim = time.time()
  print("tempoTotal",round(fim-init), '[s]')

__main__()

