# -*- coding: utf-8 -*-
"""Cópia de atividade_1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hsogp1rvHjoMM2i_zcTgs1Bohzun2Lfb
"""

#!pip install ortools

#################################################################################################
# Problema do Caixeiro Viajante
#Copyright 2023 Mateus Chacon, Mario Villalba, Danielle Gomes e Felipe Ribeiro

# Este programa é um software livre, você pode redistribuí-lo e/ou modificá-lo
# sob os termos da Licença Pública Geral GNU como publicada pela Fundação do Software Livre (FSF),
# na versão 3 da Licença, ou (a seu critério) qualquer versão posterior.

# Este programa é distribuído na esperança de que possa ser útil, mas SEM NENHUMA GARANTIA,
# e sem uma garantia implícita de ADEQUAÇÃO a qualquer MERCADO ou APLICAÇÃO EM PARTICULAR.

# Veja a Licença Pública Geral GNU para mais detalhes
#################################################################################################
from time import gmtime, strftime
from ortools.linear_solver import pywraplp
import tsplib95
import networkx as nx
import numpy as np
import time
#************************************************************************************************
#FUNÇÃO DE LEITURA
#************************************************************************************************
def leia(fileAq):
  problem = tsplib95.load(fileAq)
  graph = problem.get_graph()
  return nx.to_numpy_array(graph)
#************************************************************************************************
#FUNÇÃO QUE EXECUTA O SOLVER
#************************************************************************************************
def modelo(distances, subTours ,useMTZ=True, writeLp=False):
  n = distances.shape[0]

  #criando as variaveis xij
  solver = pywraplp.Solver.CreateSolver('SAT')
  x = {}
  for i in range(n):
      for j in range(n):
          if i != j:
            vname = f'x_{i}_{j}'
            x[i,j] = solver.BoolVar(vname)

  # criando a função objetiva
  solver.Minimize(solver.Sum(distances[i, j] * x[i, j] for i in range(n) for j in range(n) if i != j))

  # adicionando restrição para todo i
  for i in range(n):
      solver.Add(solver.Sum(x[i, j] for j in range(n) if i != j) == 1, name=f'degree_{i}')

  # adicionando restrição para todo j
  for j in range(n):
      solver.Add(solver.Sum(x[i, j] for i in range(n) if i != j) == 1, name=f'degree_{j}')

  # Add MTZ constraints
  if(useMTZ):
    u = {}
    for i in range(1, n):
        vname = f'u_{i}'
        u[i] = solver.IntVar(1 , n-1 ,vname)

    for i in range(1, n):
        for j in range(1, n):
            if i != j:
                solver.Add(u[i] - u[j] + (n - 1) * x[i, j] <= n - 2, name=f'mtz_{i}_{j}')

  # Add restrição sub rotas
  for m in range(len(subTours)):
        r5 = 0
        for i in range(len(subTours[m])):
            for j in range(len(subTours[m])):
                if i != j:
                    r5 += x[subTours[m][i], subTours[m][j]]
        solver.Add(r5 <= len(subTours[m]) - 1, name=f"sub_{m}_{i}_{j}")

  # gera o lp do modelo
  lp = "model-LP-"+str(strftime("%Y-%m-%dT%H:%M:%S", gmtime()))+".mps"
  if writeLp:
    with open(lp, "w") as out_f:
        mps_text = solver.ExportModelAsLpFormat(False)
        out_f.write(mps_text)

  #executa o solver
  init = time.time()
  status = solver.Solve()
  fim = time.time()
  if status == pywraplp.Solver.OPTIMAL or status == pywraplp.Solver.FEASIBLE:
    coords = []
    for i in range(n):
      for j in range(n):
        if (i != j):
          if round(x[j,i].solution_value()) == 1:
            coords.append([i,j])
    print('')
    print('Solution: Objective value =', solver.Objective().Value(), 'AND execution in =', round(fim-init), '[s]\n')
    return solver.Objective().Value(), coords
  else:
    print("Infeasible")
#************************************************************************************************
#FUNÇÃO QUE RETORNA OS SUB ROTAS
#************************************************************************************************
def createSubTours(coords):
    n = len(coords)
    cities_left = set(range(n))  # Conjunto de índices das cidades não visitadas
    sub_tours = []
    while cities_left:
        current_city = cities_left.pop()  # Inicia um novo sub-tour
        sub_tour = [current_city]
        while True:
            found_next = False
            for i in range(n):
                if coords[current_city][1] == coords[i][0] and i in cities_left:
                    current_city = i
                    sub_tour.append(current_city)
                    cities_left.remove(current_city)
                    found_next = True
                    break
            if not found_next:
                break
        sub_tours.append(sub_tour)
    return sub_tours
#************************************************************************************************
#METODOS
#************************************************************************************************
def metodos(meth,fileArq,writeLp):
  distances = leia(fileArq)
  match meth:
    case 'MTZ':
      print("==============================Executando MTZ - ",fileArq,"==============================")
      init = time.time()
      subTours = []
      fo, coords = modelo(distances,subTours,True,writeLp)
      subTours = createSubTours(coords)
      fim = time.time()
      print("MTZ - tempo total",round(fim-init), '[s]')
      return fo,subTours
    case 'PATAKI':
      print("==============================Executando PATAKI - ",fileArq,"==============================")
      init = time.time()
      subTours = []
      for i in range(100):
        print("Iteração: ",i)
        fo, coords = modelo(distances,subTours,False,writeLp)
        subToursCorrent = createSubTours(coords)

        if(len(subToursCorrent)==1):
          fim = time.time()
          print("PATAKI - tempo total",round(fim-init), '[s]')
          return fo,subToursCorrent

        subTours.extend(subToursCorrent)
        
#************************************************************************************************
#FUNÇÃO MAIN
#************************************************************************************************
def __main__():
  writeLp = False

  fileArq='bays29.tsp'
  fo, route = metodos('MTZ',fileArq,writeLp)
  print('Aquivo: ',fileArq, 'Solução: ', '\n\tFO: ',fo,'\n\tRoute:',route,'\n')
  fo, route = metodos('PATAKI',fileArq,writeLp)
  print('Aquivo: ',fileArq, 'Solução: ', '\n\tFO: ',fo,'\n\tRoute:',route,'\n')
 
  fileArq='brazil58.tsp'
  fo, route = metodos('MTZ',fileArq,writeLp)
  print('Aquivo: ',fileArq, 'Solução: ', '\n\tFO: ',fo,'\n\tRoute:',route,'\n')
  fo, route = metodos('PATAKI',fileArq,writeLp)
  print('Aquivo: ',fileArq, 'Solução: ', '\n\tFO: ',fo,'\n\tRoute:',route,'\n')

  # fileArq='si535.tsp'
  # fo, route = metodos('MTZ',fileArq,writeLp)
  # print('Aquivo: ',fileArq, 'Solução: ', '\n\tFO: ',fo,'\n\tRoute:',route,'\n')
  # fo, route = metodos('PATAKI',fileArq,writeLp)
  # print('Aquivo: ',fileArq, 'Solução: ', '\n\tFO: ',fo,'\n\tRoute:',route,'\n')

__main__()