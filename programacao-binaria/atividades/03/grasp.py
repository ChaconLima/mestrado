# -*- coding: utf-8 -*-
"""GRASP

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ahfDd_QW6B_o_hbMzGF447tASaCdU9f-

# FIRST IMPROVING

### INSTANCIA 20
"""

#################################################################################################
# GRASP
#Copyright 2023 Mateus Chacon Danielle Gomes e Quézia Maia

# Este programa é um software livre, você pode redistribuí-lo e/ou modificá-lo
# sob os termos da Licença Pública Geral GNU como publicada pela Fundação do Software Livre (FSF),
# na versão 3 da Licença, ou (a seu critério) qualquer versão posterior.

# Este programa é distribuído na esperança de que possa ser útil, mas SEM NENHUMA GARANTIA,
# e sem uma garantia implícita de ADEQUAÇÃO a qualquer MERCADO ou APLICAÇÃO EM PARTICULAR.

# Veja a Licença Pública Geral GNU para mais detalhes
#################################################################################################

import numpy as np
import csv
import time
import random
import threading
import matplotlib.pyplot as plt

with open("./instances/qbf100", "r") as file:
    linhas = file.readlines()
    linhas = linhas[1:]

listas = []

for linha in linhas:
    valores = linha.strip().split()
    numeros = [float(valor) for valor in valores]
    listas.append(numeros)

tamanho_matriz = len(listas)
matriz1 = []

for i in range(tamanho_matriz):
    linha = [0] * i + listas[i]
    matriz1.append(linha)

#MAX-QBF
#FIRST-IMPROVING

np.random.seed(int(time.time()))
# np.random.seed(67)
##===========================================
## CRIA SOLUÇÃO ALEATÓRIA
##===========================================
def random_solution(matrix, alpha):
    n = len(matrix)
    solution = []
    for i in range(n):
        if random.random() < alpha:
            solution.append(1)
        else:
            solution.append(0)
    return solution
##===========================================
## CRIA SOLUÇÃO ALEATÓRIA
##===========================================
def generate_greedy_initial_solution(matrix):
    n = len(matrix)
    solution = [0] * n 
    unassigned_variables = list(range(n))  

    while unassigned_variables:
        index = random.choice(unassigned_variables)
        current_score = evaluate_solution(solution, matrix)
        solution[index] = 1
        new_score = evaluate_solution(solution, matrix)

        if new_score <= current_score:
            solution[index] = 0
        unassigned_variables.remove(index)

    return solution
##===========================================
## FUNÇÃO QUE CALCULA FO
##===========================================
def evaluate_solution(solution, matrix):
    n = len(matrix)
    score = 0
    for i in range(n):
        for j in range(n):
            score += solution[i] * matrix[i][j] * solution[j]
    return score
##===========================================
## Metodo de pertubaçao
##===========================================
def first_improvement(solution, matrix):
    n = len(matrix)
    best_score = evaluate_solution(solution, matrix)

    for i in range(n):
        current_solution = list(solution)
        current_solution[i] = 1 - current_solution[i]  # Flip the bit

        current_score = evaluate_solution(current_solution, matrix)
        if current_score > best_score:
            solution = current_solution
            best_score = current_score

    return solution, best_score
##===========================================
## METODO PRINCIPAL DO GRASP
##===========================================
def grasp(matrix, alpha, max_iter, time_limit_seconds):
    n = len(matrix)
    # best_solution = random_solution(matrix, alpha)
    best_solution = generate_greedy_initial_solution(matrix)
    best_score = evaluate_solution(best_solution, matrix)
    start_time = time.time()

    for iteration in range(1, max_iter + 1):
        # current_solution = random_solution(matrix, alpha)
        current_solution = generate_greedy_initial_solution(matrix)
        current_solution, current_score = first_improvement(current_solution, matrix)

        if current_score > best_score:
            best_solution = current_solution
            best_score = current_score

        elapsed_time = time.time() - start_time
        if elapsed_time >= time_limit_seconds:
            break

    return best_solution, best_score, elapsed_time
##===========================================
## Processos
##===========================================
x={}
def processo(matrix,alpha,max_iter,time_limit_seconds,id):
    print('Iniciando_Processo_'+str(id))
    best_solution, best_score, elapsed_time = grasp(matrix, alpha, max_iter, time_limit_seconds)
    x[str(alpha)+"|"+str(max_iter)] = {
        'alpha':alpha,
        'max_iter':max_iter,
        'melhor_solucao':best_solution,
        'melhor_pontuacao':best_score,
        'tempo':elapsed_time
    }
    print('Finalizando Processo_'+str(id))
def executa(matrix, time_limit_seconds, processos):
    x.clear()
    threads = []
    id = 0
    for alpha, max_iter in processos:
        thread = threading.Thread(target=processo, args=(matrix, alpha, max_iter,time_limit_seconds,id))
        threads.append((thread,id))
        thread.start()
        id=id+1
    
    for thread,id in threads:
        thread.join()
 
    c = []
    fo = []
    time = []
    for chave in x.keys():
        s = x[chave]
        c.append(str(chave))
        fo.append(s['melhor_pontuacao'])
        time.append(s['tempo'])
        print(s)

    plt.figure(figsize=(20, 10)) 
    plt.bar(c,fo)
    plt.title('Gráfico de soluções')
    plt.xlabel('Parametros (alpha|maxIter)')
    plt.ylabel('Valores (FO)')
    for i in range(len(c)):
        plt.text(c[i], fo[i] +0.5, str(fo[i]), ha='center', va='bottom')
    plt.savefig('FO_grafico.png')
    # plt.show()
    
    plt.figure(figsize=(20, 10)) 
    plt.plot(c,time)
    plt.title('Gráfico de soluções')
    plt.xlabel('Parametros (alpha|maxIter)')
    plt.ylabel('Tempo')
    plt.savefig('TE_grafico.png')
    # plt.show()

##===========================================
## Instancias de testes
##===========================================
def instancias(matrix):

    # Instância |x| MAX-QBF (Z∗)    MAX-QBFAC (Z∗)
    # qbf020 20     151             104
    # qbf040 40     429             251
    # qbf060 60     > 572           > 396
    # qbf090 80     > 965           > 586
    # qbf100 100    > 1451          > 862
    # alpha = [0.2,0.4,0.6,0.8]
    alpha = [0]
    max_iter = [100,500,1000,1500]
    time_limit_seconds = 1000000000

    processos=[]
    for i in range(len(alpha)):
        for j in range(len(max_iter)):
            processos.append((alpha[i],max_iter[j]))
    executa(matrix=matrix,time_limit_seconds=time_limit_seconds,processos=processos)
##===========================================
## FUNÇÃO MAIN
##===========================================
if __name__ == "__main__":
    matrix = matriz1
    instancias(matrix)
    # alpha = 0.4
    # max_iter = 1000
    # time_limit_seconds = 1800

    # best_solution, best_score, elapsed_time = grasp(matrix, alpha, max_iter, time_limit_seconds)

    # print("Melhor solução:", best_solution)
    # print("Melhor pontuação:", best_score)
    # print("Tempo decorrido (segundos):", elapsed_time)

    


#MAX-QBF
#FIRST-IMPROVING

##===========================================
## FUNÇÃO MAIN
##===========================================